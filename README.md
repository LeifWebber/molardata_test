# React + Vite + Threejs 高性能点云渲染上色工具

> 为了达成在三四线小城市用户的普通浏览器算力下毫秒级的响应速度，我在渲染、计算几何和内存管理方面进行了深度的考虑和技术优化。  

## 一. 如何使用？

**请先将你要加载的模型文件放进 `src\assets\pcds` 文件夹内**。  

程序分为查看器模式和套索模式，  

### 查看器模式

查看渲染的 pcd 文件，提供了一个 select 组件来选择要渲染的文件。  

**笔试题里的所有 pcd 文件我都放进了 `src\assets\pcds` 文件夹方便您使用。**  

### 套索模式

在这个模式里可以选中要上色的点云并完成上色，可以多次选择，每一次都会覆盖上一次的上色结果。  

> [!note] 切换两种模式
> 顶部的导航栏里可以优雅的切换这两种模式，并展示出每次套索选择的完整处理时间。    

> [!tip] 关于计时器  
> 总耗时包括：
> 
> 1. **数据获取**：从 Three.js 几何体中获取点云位置数据
> 2. **坐标投影**：将所有 3D 点投影到 2D 屏幕坐标
> 3. **碰撞检测**：批量检测哪些点在用户绘制的套索多边形内
> 4. **统计计数**：统计选中的点数量
> 5. **颜色更新**：将选中的点设置为浅绿色

## 二. 我优化了什么？

当用户使用套索工具圈选时，我们需要：

1.  将百万个 3D 点坐标 $(x, y, z)$ 投影到 2D 屏幕坐标 $(u, v)$。

2.  对这百万个 2D 点逐一进行"点在多边形内" 的几何测试。

3.  更新被选中点的颜色属性并上传至 GPU。

我主要对上述的过程进行优化。  

### 1. 优化的坐标投影

常规的 Three.js `vector.project(camera)` 方法在处理单点时非常方便，但在循环中处理百万次时会产生巨大的性能开销：这将创建百万个 `Vector3` 对象，触发大量的垃圾回收（GC），且函数调用开销巨大。

**优化方案：手动矩阵运算**

我们在 `src/utils/projection.ts` 中实现了 `projectPointsToScreen` 函数，完全绕过了 Three.js 的对象层：

**预计算 MVP 矩阵**：在循环外计算好模型视图投影矩阵（Model-View-Projection Matrix）。
程序直接读取 `Float32Array` 格式的 `position` 属性，不创建任何中间对象，并手动内联数学公式，将矩阵向量乘法展开为简单的加乘运算。  
  

### 2. 高性能几何搜索算法

在获得屏幕坐标后，我们需要判断点是否在套索（多边形）内。

**优化点 I：空间网格加速，避免遍历所有点**

因为用户圈选的区域通常远小于整个屏幕，所以只有落在边界框内的点，程序才运行昂贵的射线法。这一步通常能剔除大部分点，带来性能提升。  

**优化点 II：扁平化内存布局**

在 `src/utils/pointInPolygon.ts` 中，没有将多边形顶点存储为对象数组 `[{x:1, y:1}, ...]`，而是预处理为两个独立的 `Float32Array`（`polyX` 和 `polyY`）。这提高了 CPU 缓存命中率，因为数组在内存中是连续的。  

  

### 3. 零拷贝与内存友好的渲染更新

在 Three.js 中更新几何体属性是昂贵的操作。

我直接通过 `geometry.attributes.color.array` 获取底层的 `Float32Array` 引用。

仅遍历选中的索引，直接修改内存中的 RGB 值，最后标记 `needsUpdate = true`。这确保了数据只在 CPU 和 GPU 之间传输一次，且没有任何额外的对象分配。

  

### 4. 多线程架构（Web Worker 准备就绪）  

我预留了 Web Worker 接口 `src/workers/lassoWorker.ts`，设计用于接收 `ArrayBuffer`（通过 Transferable Objects 零拷贝传输），在后台线程执行投影和计算。对于更大规模（如千万级）的数据集。  

当前的同步优化已经足够在主线程处理数百万点，所以我暂时没启用。  

如果后续出现 UI 掉帧，只需切换到此 Worker 模式即可避免。  
